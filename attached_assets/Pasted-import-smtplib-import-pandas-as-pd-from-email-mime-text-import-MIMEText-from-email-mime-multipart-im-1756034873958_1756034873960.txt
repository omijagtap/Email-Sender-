import smtplib import pandas as pd from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart import time import datetime import re import os import sys # ----------------- WELCOME & MODE ----------------- # print("üéØ Welcome to the UpGrad Email Sender!") print("Choose mode:") print("1Ô∏è‚É£ Personalized emails (replace <attributes> for each learner)") print("2Ô∏è‚É£ Bulk BCC (same email to all learners, no attributes)") mode = input("Enter 1 or 2: ").strip() if mode not in ['1', '2']: print("‚ùå Invalid choice. Exiting.") exit() if mode == '1': print("‚úÖ You selected Personalized emails.") else: print("‚úÖ You selected Bulk BCC emails.") # ----------------- CONFIG ----------------- # SMTP_SERVER = 'smtp.office365.com' SMTP_PORT = 587 SENDER_EMAIL = "intlesgcidba@upgrad.com" # Replace PASSWORD = "htmwlfsdhjjmxlls" # Replace # ----------------- FUNCTIONS ----------------- # def extract_placeholders(template): """Extract placeholders in the format <Placeholder> from template""" all_phs = re.findall(r'<([^<>]+)>', template) unique_phs = list(dict.fromkeys(all_phs)) return all_phs, unique_phs def is_valid_email(email): """Validate email format""" pattern = r'^[\w\.-]+@[\w\.-]+\.\w+$' return re.match(pattern, str(email)) is not None def row_missing_fields(row, placeholders): """Check missing data in mandatory fields""" missing = [] if not is_valid_email(row['Email']): missing.append('Email (Invalid)') for ph in placeholders: if ph in row and (pd.isna(row[ph]) or str(row[ph]).strip() == ''): missing.append(ph) return missing # ----------------- STEP 1: Subject ----------------- # subject = input("Enter the email subject line: ").strip() if not subject: print("‚ùå Email subject is required. Exiting.") exit() # ----------------- STEP 2: Template ----------------- # TEMPLATE_FILE = input("Enter full path of your TXT template file: ").strip() if not os.path.isfile(TEMPLATE_FILE) or not TEMPLATE_FILE.endswith('.txt'): print("‚ùå Invalid template file. Exiting.") exit() with open(TEMPLATE_FILE, 'r', encoding='utf-8') as f: template = f.read() all_placeholders, unique_placeholders = extract_placeholders(template) print(f"\n‚úÖ Found {len(all_placeholders)} placeholders (duplicates included).") print(f"Unique placeholders: {unique_placeholders}") # ----------------- Mode 2 Validation ----------------- # if mode == '2' and len(unique_placeholders) > 0: print("‚ùå Template contains placeholders, but Bulk BCC mode does not support attributes.") restart = input("Do you want to restart? (yes/no): ").strip().lower() if restart == 'yes': os.execv(sys.executable, ['python'] + sys.argv) else: print("‚ùå Exiting program.") exit() # ----------------- STEP 3: CSV ----------------- # CSV_FILE = input("Enter full path of your CSV file: ").strip() if not os.path.isfile(CSV_FILE) or not CSV_FILE.endswith('.csv'): print("‚ùå Invalid CSV file. Exiting.") exit() df = pd.read_csv(CSV_FILE) if 'Email' not in df.columns: print("‚ùå CSV must contain 'Email' column. Exiting.") exit() # ----------------- STEP 3a: Handle Missing Placeholders ----------------- # for ph in unique_placeholders: if ph not in df.columns: print(f"‚ö† Column '{ph}' not found in CSV.") choice = input(f"Do you want to add '{ph}' as blank column? (yes/no): ").strip().lower() if choice == 'yes': df[ph] = '' print(f"‚úÖ Added blank column for '{ph}'") else: print(f"‚ùå Missing required column '{ph}'. Exiting.") exit() # ----------------- STEP 3b: Extra Columns ----------------- # extra_cols = [col for col in df.columns if col not in unique_placeholders + ['Email', 'MissingFields']] if extra_cols: print(f"‚ÑπÔ∏è Note: Your CSV has extra columns not used in template: {extra_cols}") # ----------------- STEP 4: Row Validation ----------------- # df['MissingFields'] = df.apply(lambda row: row_missing_fields(row, unique_placeholders), axis=1) df_valid = df[df['MissingFields'].apply(lambda x: len(x) == 0)] df_invalid = df[df['MissingFields'].apply(lambda x: len(x) > 0)] print(f"\nüìä CSV Validation Summary:") print(f"Total rows: {len(df)}") print(f"‚úÖ Ready to send: {len(df_valid)}") print(f"‚ö† Rows with issues: {len(df_invalid)}") if len(df_invalid) > 0: print("\nPreview invalid rows:") print(df_invalid[['Email', 'MissingFields']].head()) choice = input("\nDo you want to continue with only valid rows? (yes/no): ").strip().lower() if choice != 'yes': print("‚ùå Exiting. Please fix CSV and try again.") exit() if len(df_valid) == 0: print("‚ùå No valid rows to send. Exiting.") exit() # ----------------- STEP 5: Final Draft Preview ----------------- # print("\nüìß Final Draft Preview (using first valid row):") first_row = df_valid.iloc[0].to_dict() preview_text = template for ph in unique_placeholders: preview_text = preview_text.replace(f"<{ph}>", str(first_row[ph])) print("\n--- PREVIEW ---") print(preview_text) # ----------------- STEP 6: Test Email ----------------- # test_email = input("\nEnter a test email to preview (or leave blank to skip): ").strip() if test_email: print("\nüìß Test Email Preview:") print(preview_text) confirm_test = input(f"Send this preview to {test_email}? (yes/no): ").strip().lower() if confirm_test == 'yes': try: server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT) server.starttls() server.login(SENDER_EMAIL, PASSWORD) msg = MIMEMultipart() msg['From'] = SENDER_EMAIL msg['To'] = test_email msg['Subject'] = subject msg.attach(MIMEText(preview_text, 'plain')) server.send_message(msg) print(f"‚úÖ Test email sent to {test_email}") server.quit() except Exception as e: print(f"‚ùå Test email failed: {e}") # ----------------- STEP 7: Confirm Sending ----------------- # print(f"\n‚ö† You are about to send {len(df_valid)} emails.") confirm = input("Proceed? (yes/no): ").strip().lower() if confirm != 'yes': print("‚ùå Cancelled.") exit() # ----------------- STEP 8: Send Emails ----------------- # server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT) server.starttls() server.login(SENDER_EMAIL, PASSWORD) status_list = [] if mode == '1': # Personalized for _, row in df_valid.iterrows(): learner = row.to_dict() email_addr = learner['Email'] body = template for ph in unique_placeholders: body = body.replace(f"<{ph}>", str(learner[ph])) msg = MIMEMultipart() msg['From'] = SENDER_EMAIL msg['To'] = email_addr msg['Subject'] = subject msg.attach(MIMEText(body, 'plain')) try: server.send_message(msg) print(f"‚úÖ Sent to {email_addr}") status_list.append({'Email': email_addr, 'Status': 'Sent'}) except Exception as e: print(f"‚ùå Failed for {email_addr}: {e}") status_list.append({'Email': email_addr, 'Status': f'Failed ({e})'}) time.sleep(1) else: # Bulk BCC msg = MIMEMultipart() msg['From'] = SENDER_EMAIL msg['To'] = SENDER_EMAIL msg['Subject'] = subject msg.attach(MIMEText(template, 'plain')) bcc_list = df_valid['Email'].tolist() try: server.sendmail(SENDER_EMAIL, bcc_list, msg.as_string()) print(f"‚úÖ Bulk email sent to {len(bcc_list)} learners.") for e in bcc_list: status_list.append({'Email': e, 'Status': 'Sent'}) except Exception as e: print(f"‚ùå Bulk BCC failed: {e}") for e in bcc_list: status_list.append({'Email': e, 'Status': f'Failed ({e})'}) server.quit() # ----------------- STEP 9: Save Report ----------------- # date_str = datetime.datetime.now().strftime("%d-%B-%Y") report_txt = f"{subject} - {date_str}.txt" with open(report_txt, "w", encoding="utf-8") as f: f.write("--- EMAIL REPORT ---\n") f.write(f"Subject: {subject}\n") f.write(f"Date: {date_str}\n\n") f.write(f"Total rows: {len(df)}\n") f.write(f"‚úÖ Sent: {len([s for s in status_list if s['Status']=='Sent'])}\n") f.write(f"‚ö† Failed: {len([s for s in status_list if s['Status'].startswith('Failed')])}\n") f.write(f"üö´ Skipped (invalid): {len(df_invalid)}\n\n") f.write("Detailed Status:\n") for s in status_list: f.write(f"{s['Email']} --> {s['Status']}\n") print("\n--- SUMMARY ---") print(f"Total rows: {len(df)}") print(f"‚úÖ Sent: {len([s for s in status_list if s['Status']=='Sent'])}") print(f"‚ö† Failed: {len([s for s in status_list if s['Status'].startswith('Failed')])}") print(f"üö´ Skipped (invalid): {len(df_invalid)}") print(f"üìÇ TXT Report saved: {report_txt}")